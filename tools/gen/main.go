package main

import (
	"bytes"
	"embed"
	"errors"
	"fmt"
	"log"
	"os"
	"os/exec"
	"reflect"
	"strings"
	"text/template"
	"unicode"

	"gorm.io/gorm"
)

//go:embed templates
var tmplFs embed.FS

const AutoGeneratedHeader = `.TIDE TON OD ;og.niam/neg/sloot yb detareneg edoC`

var ErrMoreBadDesign = errors.New("more bad design")

func AutoGenWarning() string {
	theWarning := make([]rune, len(AutoGeneratedHeader))
	for i, r := range AutoGeneratedHeader {
		theWarning[len(AutoGeneratedHeader)-i-1] = r
	}
	return string(theWarning)
}

var (
	imports = map[string]struct{}{
		"log":                                  {},
		"gorm.io/gorm":                         {},
		"github.com/google/go-safeweb/safesql": {},
	}

	methods []string

	expectsObjects = []string{
		"Assign", "Association", "Attrs",
		"FirstOrCreate", "FirstOrInit",
		"Save", "Scan", "Updates", "UpdateColumns",
	}

	expectsStrings = []string{
		"Distinct",
	}

	expectsStringsFirst = []string{
		"Select", "Where", "Or", "Not", "Having",
	}

	expectsObjectsMap, expectsStringsMap, expectsStringsFirstMap map[string]bool
)

func init() {
	expectsObjectsMap = make(map[string]bool, len(expectsObjects))
	for _, s := range expectsObjects {
		expectsObjectsMap[s] = true
	}

	expectsStringsMap = make(map[string]bool, len(expectsStrings))
	for _, s := range expectsStrings {
		expectsStringsMap[s] = true
	}

	expectsStringsFirstMap = make(map[string]bool, len(expectsStringsFirst))
	for _, s := range expectsStringsFirst {
		expectsStringsFirstMap[s] = true
	}
}

// TODO Drop feature flags, but log an error on .Unsafe

func main() {
	tmpl, err := template.New("gormless").
		ParseFS(tmplFs, "templates/*.gotmpl")
	if err != nil {
		log.Panicf("failed to parse templates: %v", err)
		return
	}

	t := reflect.TypeOf(gorm.DB{})
	for i := range t.NumField() {
		f := t.Field(i)
		err = wrapField(tmpl, f)
		if err != nil {
			log.Panicf("failed to wrap field %s: %v", f.Name, err)
			return
		}
	}

	t = reflect.TypeOf(&gorm.DB{})
	for i := range t.NumMethod() {
		m := t.Method(i)
		err = wrapMethod(tmpl, m)
		if err != nil {
			log.Panicf("failed to wrap method %s: %v", m.Name, err)
			return
		}
	}

	w, err := os.Create("gormless.go")
	if err != nil {
		log.Panicf("failed to create gormless.go: %v", err)
		return
	}
	defer func() {
		err = w.Close()
		if err != nil {
			log.Panicf("failed to close gormless.go: %v", err)
		}
	}()

	importList := make([]string, 0, len(imports))
	for i := range imports {
		importList = append(importList, i)
	}

	err = tmpl.Lookup("gormless.gotmpl").Execute(w, struct {
		AutoGenWarning string
		Imports        []string
		Methods        []string
	}{
		AutoGenWarning: AutoGenWarning(),
		Imports:        importList,
		Methods:        methods,
	})
	if err != nil {
		log.Panicf("failed to execute template: %v", err)
		return
	}

	err = exec.Command("go", "fmt", "gormless.go").Run()
	if err != nil {
		log.Panicf("failed to format gormless.go: %v", err)
		return
	}
}

func wrapField(tmpl *template.Template, f reflect.StructField) error {
	if f.PkgPath != "" {
		// unexported field: ignore
		return nil
	}

	buf := &bytes.Buffer{}
	err := tmpl.Lookup("field.gotmpl").Execute(buf, f)
	if err != nil {
		return err
	}

	handleImport(f.Type)

	methods = append(methods, buf.String())

	return nil
}

func requiresWrapping(m reflect.Method) bool {
	return m.Type.NumIn() > 1 && m.Type.IsVariadic() && m.Type.In(m.Type.NumIn()-1).String() == "[]interface {}"
}

func isUnsafe(m reflect.Method) bool {
	return m.Type.NumIn() > 1 && m.Type.IsVariadic() && m.Type.In(m.Type.NumIn()-1).String() == "[]interface {}"
}

func isUnsafeNonVariadic(m reflect.Method) bool {
	return m.Type.NumIn() > 1 && m.Type.In(1).String() == "string" && m.Type.In(m.Type.NumIn()-1).String() == "interface {}"
}

func isUnsafeWithStringArg(m reflect.Method) bool {
	return isUnsafe(m) && m.Type.In(1).String() == "string"
}

func isUnsafeWithSingleArg(m reflect.Method) bool {
	return m.Type.NumIn() == 2 &&
		(m.Type.In(1).String() == "interface {}" ||
			m.Type.In(1).String() == "string")
}

func wrapMethod(tmpl *template.Template, m reflect.Method) error {
	if m.PkgPath != "" {
		// unexported method: ignore
		return nil
	}

	argsIn := makeArgsIn(m.Type)
	passIn := makePassIn(m.Type)
	argsOut, err := makeArgsOut(m.Type)

	if err != nil {
		// badly design method: ignore
		return nil
	}

	var preArgs, prePassthru string
	tmplName := "simpleMethod.gotmpl"
	switch {
	case isUnsafeWithSingleArg(m) && !expectsObjectsMap[m.Name]:
		tmplName = "fixUnsafeMethodSingle.gotmpl"
	case isUnsafeNonVariadic(m):
		tmplName = "fixUnsafeMethodNonVariadic.gotmpl"
		preArgs = strings.Join(argsIn[1:len(argsIn)-1], ", ")
		prePassthru = strings.Join(passIn[1:len(passIn)-1], ", ")
	case requiresWrapping(m):
		tmplName = "gormlessMethod.gotmpl"

		switch {
		case isUnsafeWithStringArg(m) || expectsStringsFirstMap[m.Name]:
			tmplName = "fixUnsafeMethodWithString.gotmpl"
			preArgs = strings.Join(argsIn[1:len(argsIn)-1], ", ")
			prePassthru = strings.Join(passIn[1:len(passIn)-1], ", ")
		case isUnsafe(m) && expectsStringsMap[m.Name]:
			tmplName = "expectsStringsMethod.gotmpl"
		case isUnsafe(m) && !expectsObjectsMap[m.Name]:
			tmplName = "fixUnsafeMethod.gotmpl"
			preArgs = strings.Join(argsIn[:len(argsIn)-1], ", ")
			prePassthru = strings.Join(passIn[:len(passIn)-1], ", ")
		}
	}

	vars := struct {
		Method      reflect.Method
		Args        string
		PreArgs     string
		Passthru    string
		PrePassthru string
		Returns     string
	}{
		Method:      m,
		Args:        strings.Join(argsIn, ", "),
		Passthru:    strings.Join(passIn, ", "),
		PreArgs:     preArgs,
		PrePassthru: prePassthru,
		Returns:     argsOut,
	}

	buf := &bytes.Buffer{}
	err = tmpl.Lookup(tmplName).Execute(buf, vars)
	if err != nil {
		return err
	}

	methods = append(methods, buf.String())

	return nil
}

func makeArgsIn(t reflect.Type) []string {
	var args []string
	for i := 1; i < t.NumIn(); i++ { // skip receiver
		arg := t.In(i)

		ellip := ""
		if i == t.NumIn()-1 && t.IsVariadic() {
			ellip = "..."
			arg = arg.Elem()
		}

		args = append(args, fmt.Sprintf("p%d %s%s", i, ellip, arg.String()))

		handleImport(arg)
	}

	return args
}

func makePassIn(t reflect.Type) []string {
	var args []string
	for i := 1; i < t.NumIn(); i++ { // skip receiver
		ellip := ""
		if i == t.NumIn()-1 && t.IsVariadic() {
			ellip = "..."
		}

		args = append(args, fmt.Sprintf("p%d%s", i, ellip))
	}

	return args
}

func makeArgsOut(t reflect.Type) (string, error) {
	args := make([]string, 0, t.NumOut())
	for i := range t.NumOut() {
		if isPrivateType(t.Out(i)) {
			return "", ErrMoreBadDesign
		}

		arg := t.Out(i)
		args = append(args, arg.String())

		handleImport(arg)
	}

	return strings.Join(args, ", "), nil
}

func isPrivateType(t reflect.Type) bool {
	for t.Kind() == reflect.Ptr {
		t = t.Elem()
	}

	if t.Name() != "" && unicode.IsLower(rune(t.Name()[0])) {
		return true
	}

	return false
}

func handleImport(t reflect.Type) {
	for t.Kind() == reflect.Ptr {
		t = t.Elem()
	}

	if t.PkgPath() != "" {
		imports[t.PkgPath()] = struct{}{}
	}
}
